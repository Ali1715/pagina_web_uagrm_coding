<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no , initial-scale=1.0 , maximum-scale=1.0">

    <!-- Bootstrap CSS -->
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
 

<link rel="stylesheet" href="stylesI.css">
    <title>UAGRM CODING</title>
  </head>
  <body>

  <div class="contenedor">
  <div class="topnav scrolling-navbar fixed-top">

   <a href="index.html">UAGRM CODING</a>
   <!-- <a href="#Arquitectura del computador">Arquitectura</a> PARA HACER LA REFERENCIA INTERNA-->
  <a href="#Arquitectura del computador">Arquitectura</a>
   <a href="#Registros">Registros</a>
  <a href="#Etiqutas">Etiquetas</a>
  <a href="#Subrutinas">Subrutinas</a>
   <a href="#System calls">System call</a>
    <a href="#Operadores">Operadores</a>
  
</div>

 
   <header class="showcase">
    <h1>UAGRM CODING</h1>
	<img src="logo1jpeg.png" class="rounded mx-auto d-block"  >
   </header>
   
   <div class="container">
   <div class="center">
     <br>
	   <br>
        <h1 style="color:Tomato;"> Programación
en Ensamblador </h1></div>
<!-- <a name="Arquitectura del computador"> </a> PARA ENVIAR  LA REFERENCIA AQUI --->
 <br>
<a name="Arquitectura del computador"></a>
<!-- TERMINA LA REFERENCIA A ARQUITECTURA AQUI-->

<BR>
<BR>
<h2>1. Arquitectura del computador
</h2>
<h2>1.1.1. Modo extendido de 64 bits
</h2>
<p class="parrafo"><h3>El modo extendido de 64 bits es utilizado por los sistemas operativos de 64
bits. Dentro de este modo general, se dispone de un modo de operación de
64 bits y de un modo de compatibilidad con los modos de operación de las
arquitecturas de 16 y 32 bits.</h3></p>
<p></p>

<p class="parrafo"><h3>En un sistema operativo de 64 bits, los programas de 64 bits se ejecutan en
modo de 64 bits y las aplicaciones de 16 y 32 bits se ejecutan en modo de
compatibilidad. Los programas de 16 y 32 bits que se tengan que ejecutar en
modo real o virtual x86 no se podrán ejecutar en modo extendido si no son
emulados.</h3></p>

<!--  -->

<h2>1.1.2. Modo heredado de 16 y 32 bits</h2>
<p class="parrafo"><h3>
    El modo heredado de 16 y 32 bits es utilizado por los sistemas operativos
    de 16 y 32 bits. Cuando el sistema operativo utiliza los modos de 16 bits o
    de 32 bits, el procesador actúa como un procesador x86 y solo se puede
    ejecutar código de 16 o 32 bits. Este modo solo permite utilizar
    direcciones de 32 bits, de manera que limita el espacio de direcciones
    virtual a 4 GB.</h3>
</p>
<p class="parrafo"><h3>
    1) 
    Modo real: 
    Implementa el modo de programación del Intel 8086, con algunas extensiones,
    como la capacidad de poder pasar al modo protegido o al modo de gestión del
    sistema. El procesador se coloca en modo real al iniciar el sistema y
    cuando este se reinicia.
</p>
<p class="parrafo"><h3>
    2) 
    Modo protegido
    : Este es el modo por defecto del procesador. Permite utilizar
    características como la memoria virtual, la paginación o la computación
    multitarea.
</p>
<p class="parrafo"><h3>
    3) 
    Modo virtual 8086
    : Este modo permite ejecutar programas de 16 bits como tareas dentro del
    modo protegido.
</p>


<!-- -->


<h2>1.2  El modo de 64 bits</h2>
<p  class="parrafo"><h3>
    Los elementos que desde el punto de vista del programador son visibles en
    este modo de operación son los siguientes:
</p>
<p class="parrafo"><h3>
    1) Espacio de memoria: un programa en ejecución en este
    modo puede acceder a un espacio de direcciones lineal de 264 bytes. El
    espacio físico que realmente puede dirigir el procesador es inferior y
    depende de la implementación concreta de la arquitectura.
</p>
<p class="parrafo"><h3>
    2) Registros: hay 16 registros de propósito general de 64
    bits, que soportan operaciones de byte (8 bits), Word (16 bits), double
    word (32 bits) y quad word (64 bits).
</p>
<p class="parrafo"><h3>
    • El registro contador de programa (RIP, instruction pointer register) es
    de 64 bits.
</p>
<p class="parrafo"><h3>
    • El registro de bits de estado también es de 64 bits (RFLAGS). Los 32 bits
    de la parte alta están reservados; los 32 bits de la parte bajan son
    accesibles y corresponden a los mismos bits de la arquitectura IA-32
    (registro EFLAGS).
</p>
<p class="parrafo"><h3>
    • Los registros de segmento en general no se utilizan en el modo de 64
    bits.
</p>

<!--  -->

<h2> 1.2.1. Organización de la memoria</h2>
<p class="parrafo"><h3>
    Al trabajar en un espacio lineal de direcciones, no se utilizan mecanismos
    de segmentación de la memoria, de manera que no son necesarios los
    registros de segmentos, excepto los registros de segmento FS y GS, que se
    pueden utilizar como registro base en el cálculo de direcciones de los
    modos de direccionamiento relativo.
</p>
<p class="parrafo"><h3>
    Paginación: 
    Este mecanismo es transparente para los programas de aplicación, y por lo
    tanto para el programador, y viene gestionado por el hardware del
    procesador y el sistema operativo.
</p>
<p class="parrafo"><h3>
    Las direcciones virtuales son traducidas a direcciones físicas de memoria
    utilizando un sistema jerárquico de tablas de traducción gestionadas por el
    software del sistema (sistema operativo).
</p>
<p class="parrafo"><h3>
    Orden de los bytes: 
    Los procesadores x86-64 utilizan un sistema de ordenación de los bytes
    cuando se accede a los datos que se encuentran almacenados en la
    memoria. En concreto, se utiliza un sistema little-endian, en el cual el
    byte de menos peso de un dato ocupa la dirección más baja de memoria.
</p>
<p class="parrafo"><h3>
    Tamaño de las direcciones: 
    Los programas que se ejecutan en el modo de 64 bits generan directamente
    direcciones de 64 bits.
</p>
<p class="parrafo"><h3>
    Modo compatibilidad:
    Los programas que se ejecutan en el modo compatibilidad generan direcciones
    de 32 bits. Estas direcciones son extendidas añadiendo ceros a los 32 bits
    más significativos de la dirección. Este proceso es gestionado por el
    hardware del procesador y es transparente para el programador.
</p>
<p class="parrafo"><h3>
    
        Tamaño de los desplazamientos y de los valores inmediatos:
    
    En el modo de 64 bits los desplazamientos utilizados en los
    direccionamientos relativos y los valores inmediatos son siempre de 32
    bits, pero vienen extendidos a 64 bits manteniendo el signo. Hay una
    excepción a este comportamiento: en la instrucción MOV se permite
    especificar un valor inmediato de 64 bits.
</p>

<!-- <a name="Registros"> </a> PARA ENVIAR  LA REFERENCIA AQUI --->
 <p></p>
<a name="Registros"></a>
<!-- TERMINA LA REFERENCIA A ARQUITECTURA AQUI-->
 <BR>
 <BR>
<h2>1.2.2. Registros
</h2>
<p class="parrafo"><h3>Los procesadores de la arquitectura x86-64 disponen de un banco de registros
formado por registros de propósito general y registros de propósito específico.</h3></p>
<p></p>

<p class="parrafo"><h3>Registros de propósito general hay 16 de 64 bits y de propósito específico hay
6 registros de segmento de 16 bits, también hay un registro de estado de 64
bits (RFLAGS) y un registro contador de programa también de 64 bits (RIP).</h3></p>

<!-- -->

<h2>Registros de propósito general
</h2>
<p class="parrafo"><h3>Son 16 registros de datos de 64 bits (8 bytes): RAX, RBX, RCX, RDX, RSI, RDI,
RBP, RSP y R8-R15</h3></p>
<p></p>

<p class="parrafo"><h3>Los 8 primeros registros se denominan de manera parecida a los 8 registros de
propósito general de 32 bits disponibles en la arquitectura IA-32 (EAX, EBX,
ECX, EDX, ESI, EDI, EBP y ESP).</h3></p>
<p></p>
<p class="parrafo"><h3>Los registros son accesibles de cuatro maneras diferentes:
</h3></p>
<p></p>
<p class="parrafo"><h3>1) Como registros completos de 64 bits (quad word).</h3></p>
<p></p>
<p class="parrafo"><h3>2) Como registros de 32 bits (double word), accediendo a los 32 bits de menos
peso</h3></p>
<p></p>
<p class="parrafo"><h3>3) Como registros de 16 bits (word), accediendo a los 16 bits de menos peso.</h3></p>
<p></p>
<p class="parrafo"><h3>4) Como registros de 8 bits (byte), permitiendo acceder individualmente a uno
o dos de los bytes de menos peso según el registro.</h3></p>
<p></p>
<p class="parrafo"><h3>El acceso a registros de byte tiene ciertas limitaciones según el registro. A continuación se presenta la nomenclatura que se utiliza según si se quiere acceder
a registros de 8, 16, 32 o 64 bits y según el registro.
</h3></p>
<p></p>
<div class="img1" >
<img src="registros.png" class="rounded mx-auto d-block"  >
</div>
<p></p> 
<p class="parrafo"><h3>Limitaciones en el uso de los registros de propósito general:
</h3></p>
<p></p>
<p class="parrafo"><h3>
• En una misma instrucción no se puede usar un registro del conjunto AH,
BH, CH, DH junto con uno del conjunto SIL, DIL, BPL, SPL, R8B – R15B.

</h3></p>
<p class="parrafo"><h3>

• Registro RSP: tiene una función especial, funciona como apuntador de pila, contiene siempre la dirección del primer elemento de la pila. Si lo utilizamos con otras finalidades, perderemos el acceso a la pila.

</h3></p>
<p class="parrafo"><h3>

• Registro RSP: tiene una función especial, funciona como apuntador de pila, contiene siempre la dirección del primer elemento de la pila. Si lo utilizamos con otras finalidades, perderemos el acceso a la pila.
• Cuando se utiliza un registro de 32 bits como operando destino de una
instrucción, la parte alta del registro está fijada en 0.
</h3></p>
<p></p>
<h2>Registros de propósito específico
</h2>
<h2>1)Registros de segmento: hay 6 registros de segmento de 16 bits.
</h2>
<p class="parrafo"><h3>En el modo de 64 de bits, estos registros prácticamente no se utilizan, ya que
se trabaja con el modelo de memoria lineal y el valor de estos registros se encuentra fijado en 0 (excepto en los registros FS y GS, que pueden ser utilizados
como registros base en el cálculo de direcciones).</h3></p>
<p></p>
<h2>2)Registro de instrucción o instruction pointer(RIP)
</h2>
<p class="parrafo"><h3>Es un registro de 64 bits que actúa como registro contador de programa (PC) y contiene la dirección efectiva (o dirección lineal) de la instrucción siguiente que se ha de ejecutar</h3></p>
<p></p>
<h2>3)Registro de estado o Flags register(RFLAGS)
</h2>
<p class="parrafo"><h3>contiene información sobre el estado del procesador e información sobre el
resultado de la ejecución de las instrucciones.</p>
<p></p>
<h2>3.2.1. Definición de constantes
</h2>
<p class="parrafo"><h3>Realmente una constante es un nombre que se
da para referirse a un valor determinado y quee no puede ser modificado por ninguna instrucción del código.
</p>
<p></p>
<p class="parrafo"><h3>La declaración de constantes se puede hacer en cualquier parte del programa:
al principio del programa fuera de las secciones .data, .bss, .text o dentro de
cualquiera de las secciones anteriores.
</p>
<p></p>
<p class="parrafo"><h3>Para definir constantes se utiliza la directiva equ, de la manera siguiente:
</p>
<p></p>
<p class="parrafo"><h3>nombre_constante equ valor
</p>
<p></p>
<p class="parrafo"><h3>Ejemplos de definiciones de constantes:
</p>
<p></p>
<p class="parrafo"><h3>tamañoVec equ 5
</p>
<p class="parrafo"><h3>ServicioSO equ 80h
</p>
<p class="parrafo"><h3>Mensaje1 equ 'Hola'
</p>
<p></p>
<h2>3.2.2. Definición de variables
</h2>
<p class="parrafo"><h3>La declaración de variables en un programa en ensamblador se puede incluir
en la sección .data o en la sección .bss, según el uso de cada una.
</p>
<p></p>
<h2>Sección .data, variables inicializadas
</h2>
<p class="parrafo"><h3>• db: define una variable de tipo byte, 8 bits
</p>
<p class="parrafo"><h3>• dw: define una variable de tipo palabra (word), 2 bytes = 16 bits.
</p>
<p class="parrafo"><h3>• dd: define una variable de tipo doble palabra (double word), 2 palabras =4 bytes = 32 bits.
</p>
<p class="parrafo"><h3>• dq: define una variable de tipo cuádruple palabra (quad word), 4 palabras= 8 bytes = 64 bits.
</p>
<p></p>
<p class="parrafo"><h3>Ejemplos:
</p>
<p></p>
<p class="parrafo"><h3>Los valores hexadecimales han de empezar por 0x, 0h o $, o deben finalizarcon una h.
</p>
<p class="parrafo"><h3>    -> var1 db 255 ; define una variable con el valor FFh
</p>
<p class="parrafo"><h3>    -> Var2 dw 65535 ; en hexadecimal FFFFh
</p>
<p class="parrafo"><h3>    -> var4 dd 4294967295 ; en hexadecimal FFFFFFFFh
</p>
<p class="parrafo"><h3>    -> var8 dq 18446744073709551615 ; en hexadecimal FFFFFFFFFFFFFFFFh
</p>
<p></p>

<p></p>
<p class="parrafo"><h3>Los valores numéricos se consideran por defecto en decimal, pero también se
puede indicar explícitamente que se trata de un valordecimal finalizando el
número con el carácter d</h3>
</p>
<p></p>
<p class="parrafo"><h3>    -> var db 67 ;el valor 67 decimal</h3>
<p></p>
<p class="parrafo"><h3>Los valores binarios han de empezar por 0b o finalizar con el carácter b<h3>
</p>
<p></p>
<p class="parrafo"><h3>    -> var db 0b01000011</h3>
<p class="parrafo"><h3>    -> var dw 0110_0100_0011b</h3>
<p></p>
<p class="parrafo"><h3>Los caracteres y las cadenas de caracteres han de escribirse entre comillas
simples (''), dobles ("") o comillas abiertas backquotes (` `)</h3>
<p></p>
<p class="parrafo"><h3>Las cadenas de caracteres (strings) se definen de la misma manera:</h3>
<p></p>
<p class="parrafo"><h3>    -> cadena db 'Hola' ;define una cadena formada por 4 caracteres</h3>
<p></p>
<p class="parrafo"><h3>Los vectores en ensamblador se definen con un nombre de variable e indicando a continuación los valores que forman el vector.</h3>
<p></p> 
<p class="parrafo"><h3>    -> vector1 db 23, 42, -1, 65, 14 ;vector formado por 5 valores de tipo byte</h3>
<p></p>
<h2>Sección .bss, variables no inicializadas
</h2>
<p></p>
<p class="parrafo"><h3>Dentro de esta sección se declaran y se reserva espacio para las variables de
nuestro programa para las cuales no queremos dar un valor inicial.
</h3>
<p></p>
<p class="parrafo"><h3>• resb: reserva espacio en unidades de byte</h3>
<p></p>
<p class="parrafo"><h3>• resw: reserva espacio en unidades de palabra, 2 bytes</h3>
<p></p>
<p class="parrafo"><h3>• resd: reserva espacio en unidades de doble palabra, 4 bytes</h3>
<p></p>
<p class="parrafo"><h3>• resq: reserva espacio en unidades de cuádruple palabra, 8 bytes</h3>
<p></p>
<p class="parrafo"><h3>Ejemplos</h3>
<p></p>
<p class="parrafo"><h3>section .bss</h3>
<p></p>
<p class="parrafo"><h3>var1 resb 1 ;reserva 1 byte</h3>
<p></p>
<p class="parrafo"><h3>var2 resb 4 ;reserva 4 bytes</h3>
<p></p>
<p class="parrafo"><h3>var3 resw 2 ;reserva 2 palabras = 4 bytes, equivalente al caso anterior</h3>
<p></p>
<p class="parrafo"><h3>var3 resd 1 ;reserva una cuádruple palabra = 4 bytes, equivalente a los dos casos anteriores
</h3>
<p></p>

<!-- -->
<a name="Etiqutas"></a>
<!-- TERMINA LA REFERENCIA A ARQUITECTURA AQUI-->
<h2>3. El lenguaje de ensamblador para la arquitectura x86-64 </h2>
<h2>3.3  Formato de la instrucciones 
</h2>
<h2>3.3.1. 	Etiquetas </h2>
<p class="parrafo"><h3>Una etiqueta hace referencia a un elemento dentro del programa ensamblador.
Su función es facilitar al programador la tarea de hacer referencia a diferentes
elementos del programa. Las etiquetas sirven para definir constantes, variables
o posiciones del código y las utilizamos como operandos en las instrucciones
o directivas del programa.</h3></p>
<p></p>

<p class="parrafo"><h3>EJEMPLO:</h3></p>
  
   <img src="Etiquetas.jpg" class="rounded mx-auto d-block" style="width:25%; height:auto;" >
   
   
   <h2>3.4  Juego de instrucciones y modos de direccionamiento
</h2>
<h2> 3.4.1. Tipos de operandos de las instrucciones x86-64</h2>
<h2>Operandos fuente y destino </h2>
<p class="parrafo"><h3>En las instrucciones con un solo operando, este se puede comportar solo como operando fuente, solo como operando destino o como operando fuente
y destino.
</h3></p>
<p></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>

<p class="parrafo"><h3>push rax</h3></p>

<p class="parrafo"><h5>El registro rax es un operando fuente; la instrucción almacena el valor del operando
fuente en la pila del sistema, de manera que la pila es un operando destino implícito.
</h5></p>
<p class="parrafo"><h3><p class="parrafo"><h3>En las instrucciones con dos operandos, el primer operando se puede comportar como operando fuente y/o destino, mientras que el segundo operando se
comporta siempre como operando fuente.
</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h3>mov rax, rbx</h3></p>
<p class="parrafo"><h5>El primer operando se comporta solo como operando destino; la instrucción almacena
el valor indicado por el segundo operando en el primer operando (rax = rbx).
</h5></p>
<h2>Localización de los operandos</h2>
<p class="parrafo"><h3>1. Inmediatos: En las instrucciones de dos operandos, se puede utilizar un
valor inmediato como operando fuente; algunas instrucciones de un operando
también admiten un valor inmediato como operando. Los valores inmediatos
se pueden expresar como valores numéricos (decimal, hexadecimal, octal o
binario) o como caracteres o cadenas de caracteres. También se pueden utilizar
las constantes definidas en el programa como valores inmediatos.</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>mov al, 10 b ;un valor inmediato expresado en binario</h5></p>

<p class="parrafo"><h3>2. Registros: Los registros se pueden utilizar como operando fuente y como
operando destino. Podemos utilizar registros de 64 bits, 32 bits, 16 bits y 8
bits. Algunas instrucciones pueden utilizar registros de manera implícita.</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h3>mov al, 100 </h3></p>

<p class="parrafo"><h3>3.Memoria: Las variables declaradas a memoria se pueden utilizar como operandos fuente y destino. En el caso de instrucciones con dos operandos,solo uno de los operandos puede acceder a la memoria, el otro ha de ser un
registro o un valor inmediato (y este será el operando fuente).</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5> mov rax, var1 ;se carga en rax la dirección de la variable var</h5></p>

<h2>Tamaño de los operandos</h2>
<p class="parrafo"><h3>BYTE: indica que el tamaño del operando es de un byte (8 bits).</h3></p>
<p class="parrafo"><h3>WORD: indica que el tamaño del operando es de una palabra (word) o dos
bytes (16 bits).</h3></p>
<p class="parrafo"><h3>DWORD: indica que el tamaño del operando es de una doble palabra (double word) o cuatro bytes (32 bits).
</h3></p>
<p class="parrafo"><h3> QWORD: indica que el tamaño del operando es de una cuádruple palabra
(quad word) u ocho bytes (64 bits)</h3></p>

<h2>3.4.2. Modos de direccionamiento</h2>
<h2>1.Inmediato:</h2>
<p class="parrafo"><h3> En este caso, el operando hace referencia a un dato que se encuentra en la instrucción misma. No hay que hacer ningún acceso extra a memoria para obtenerlo. Solo podemos utilizar un direccionamiento inmediato
como operando fuente. El número especificado ha de ser un valor que se pueda
expresar con 32 bits como máximo, que será el resultado de evaluar una expresión aritmética formada por valores numéricos y operadores aritméticos y
también sumar una dirección de memoria representada mediante una etiqueta (nombre de una variable), con la excepción de la instrucción mov cuando
el primer operando es un registro de 64 bits, para el que podremos especificar
un valor que se podrá expresar con 64 bits.</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>mov rax, 0102030405060708h ;el segundo operando utiliza direccionamiento inmediato expresado con 64 bits.</h5></p>
<h2>2.Directo a registro:</h2>
<p class="parrafo"><h3> En este caso, el operando hace referencia a un dato que
se encuentra almacenado en un registro. En este modo de direccionamiento
podemos especificar cualquier registro de propósito general (registros de datos,
registros índice y registros apuntadores)</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>mov rax, rbx ;los dos operandos utilizan direccionamiento directo a registro, rax = rbx</h5></p>

<h2>3.Directo a memoria:</h2>
<p class="parrafo"><h3> En este caso, el operando hace referencia a un dato que
se encuentra almacenado en una posición de memoria. El operando habrá de
especificar el nombre de una variable de memoria entre corchetes [ ]; cabe recordar que en sintaxis NASM se interpreta el nombre de una variable sin corchetes como la dirección de la variable y no como el contenido de la variable.</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>mov rax,[var] ;el segundo operando utiliza direccionamiento directo a memoria, rax = [var] </h5></p>
<h2>4.Indirecto a registro:</h2>
<p class="parrafo"><h3> En este caso, el operando hace referencia a un dato
que se encuentra almacenado en una posición de memoria. El operando habrá
de especificar un registro entre corchetes [ ]; el registro contendrá la dirección
de memoria a la cual queremos acceder</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>mov rbx, var ;se carga en rbx la dirección de la variable var</h5></p>

<!-- DEF SUBRUTINAS-->
<br>
<br>
<a name="Subrutinas"></a>
<br>
<br>

<h2> 5.4.1. Definicion de subrutinas en ensamblador</h2>
    <p class="parrafo"><h3>
   
        5.4.1. Definicion de subrutinas en ensamblador
   
</p>
<p class="parrafo"><h3>
    Una subrutina puede necesitar que se le transfieran parámetros; los
    parámetros se pueden pasar mediante registros o la pila. Sucede lo mismo
    con el re[1]torno de resultados, que puede efectuarse por medio de registro
    o de la pila. Consideraremos los casos en los que el número de parámetros
    de entrada y de retorno de una subrutina es fijo. Paso de parámetros y
    retorno de resultado por medio de registros Debemos definir sobre qué
    registros concretos queremos pasar parámetros a la subrutina y sobre qué
    registros haremos el retorno; podemos utilizar cualquier registro de
    propósito general del procesador. Una vez definidos los registros que
    utilizaremos para hacer el paso de parámetros, deberemos asignar a cada uno
    el valor que queremos pasar a la subrutina antes de hacer call; para
    devolver los valores, dentro de la subrutina, tendremos que asignar a los
    registros correspondientes el valor que se debe devolver antes de hacer
    ret. Recordemos que los registros que se utilicen para devolver un valor no
    se han de almacenar en la pila al inicio de la subrutina, ya que no hay que
    conservar el valor inicial. Supongamos que en el ejemplo del factorial
    queremos pasar como parámetro un número cuyo factorial queremos calcular, y
    devolver como resultado el factorial del número transferido como parámetro,
    implementando el paso de parámetros y el retorno de resultados por medio de
    registros. El número cuya factorial queremos calcular lo pasaremos por
    medio del registro RBX y devolveremos el resultado al registro RAX. La
    llamada de la subrutina será:
</p>
<p class="parrafo"><h3>
    mov rbx, 5
</p>
<p class="parrafo"><h3>
    call factorial
</p>
<p class="parrafo"><h3>
    ;En rax tendremos el valor del factorial de 5 (=120)
</p>
<p class="parrafo"><h3>
    Subrutina:
</p>
<p class="parrafo"><h3>
    factorial:
</p>
<p class="parrafo"><h3>
    push rbx ; Almacenar en la pila el registro que modificamos
</p>
<p class="parrafo"><h3>
    ; y que no se utiliza para devolver el resultado.
</p>
<p class="parrafo"><h3>
    ; Instrucciones de la subrutina
</p>
<p class="parrafo"><h3>
    mov rax, 1 ; rax será el resultado
</p>
<p class="parrafo"><h3>
    while:
</p>
<p class="parrafo"><h3>
    imul rax, rbx
</p>
<p class="parrafo"><h3>
    dec rbx cmp rbx, 1 ; Se hace la comparación
</p>
<p class="parrafo"><h3>
    jg while ; Si se cumple la condición salta a while
</p>
<p class="parrafo"><h3>
    ; En rax tendremos el valor del factorial de rbx
</p>
<p class="parrafo"><h3>
    pop rbx ; Restauramos el valor inicial del registro
</p>
<p class="parrafo"><h3>
    ret
</p>
<p class="parrafo"><h3>
    Paso de parámetros y retorno de resultado por medio de la pila Si queremos
    pasar parámetros y devolver resultados a una subrutina utilizando la pila,
    y una vez definidos los parámetros que queremos pasar y los que queremos
    retornar, hay que hacer lo siguiente: 1) Antes de hacer la llamada a la
    subrutina: es necesario reservar espacio en la pila para los datos que
    queremos devolver y a continuación introducir los parámetros necesarios en
    la pila. 2)Dentro de la subrutina: hay que acceder a los parámetros
    leyéndolos di[1]rectamente de memoria, utilizando un registro que apunté a
    la cima de la pila. El registro apuntador de pila, RSP, siempre apunta a la
    cima de la pila y, por lo tanto, podemos acceder al contenido de la pila
    haciendo un direccionamiento a memoria que utilice RSP, pero si utilizamos
    la pila dentro de la subrutina, no se recomienda utilizarlo. El registro
    que se suele utilizar como apuntador para acceder a la pila es el registro
    RBP. Antes de utilizarlo, lo tendremos que almacenar en la pila para poder
    recuperar el valor inicial al final de la subrutina, a continuación, se
    carga en RBP el valor de RSP. RBP no se debe cambiar dentro de la
    subrutina; al final de esta se copia el valor sobre RSP para restaurar el
    valor inicial. 3) Después de ejecutar a subrutina: una vez fuera de la
    subrutina es necesario liberar el espacio utilizado por los parámetros de
    entrada y después recuperar los resultados del espacio que hemos reservado
    antes de hacer la llamada. CC-BY-SA • PID_00178132 75 Programación en
    ensamblador (x86-64) Supongamos que en el ejemplo de la factorial queremos
    pasar como parámetro el número cuyo factorial queremos calcular y devolver
    como resultado el factorial del número pasado como parámetro, implementando
    el paso de parámetros y el retorno de resultados por medio de la pila.
</p>
<p class="parrafo"><h3>
    La llamada de la subrutina:
</p>
<p class="parrafo"><h3>
    sub rsp,8 ; Reservamos 8 bytes para el resultado que devolvemos
</p>
<p class="parrafo"><h3>
    mov rbx, 5
</p>
<p class="parrafo"><h3>
    push rbx; Introducimos el parámetro de entrada en la pila
</p>
<p class="parrafo"><h3>
    call factorial
</p>
<p class="parrafo"><h3>
    add rsp,8 ; Liberamos el espacio utilizado por el parámetro de entrada
</p>
<p class="parrafo"><h3>
    pop rax ; Recuperamos el resultado devuelto sobre el registro rax
</p>
<p class="parrafo"><h3>
    Variables locales En los lenguajes de alto nivel es habitual definir
    variables locales dentro de las funciones definidas en un programa. Las
    variables locales ocupan un espacio definido dentro de la pila. Ahora
    veremos cómo reservar espacio para variables locales en subrutinas
    definidas en ensamblador. Para reservar el espacio necesario, hemos de
    saber cuántos bytes utilizaremos como variables locales. A continuación, es
    necesario decrementar el valor del apuntador a pila RSP tantas unidades
    como bytes se quieran reservar para las variables locales; de esta manera,
    si utilizamos las instrucciones que trabajan con la pila dentro de la
    subrutina (push y pop) no sobrescribiremos el espacio de las variables
    locales. La actualización de RSP se hace justo después de actualizar el
    registro que utilizamos para acceder a la pila, RBP.
</p>
<p class="parrafo"><h3>
    subrutina:
</p>
<p class="parrafo"><h3>
    push rbp ; Almacenar el registro que utilizaremos
</p>
<p class="parrafo"><h3>
    ; de apuntador a la pila rbp
</p>
<p class="parrafo"><h3>
    mov rbp, rsp ; Asignar a RBP el valor del registro apuntador RSP
</p>
<p class="parrafo"><h3>
    sub rsp, n ; n indica el número de bytes reservados para las
</p>
<p class="parrafo"><h3>
    ; variables locales
</p>
<p class="parrafo"><h3>
    ;
</p>
<p class="parrafo"><h3>
    ; Instrucciones de la subrutina
</p>
<p class="parrafo"><h3>
    mov rsp, rbp ; Restauramos el valor inicial de RSP con
</p>
<p class="parrafo"><h3>
    RBP
</p>
<p class="parrafo"><h3>
    pop rbp ; Restauramos el valor inicial de RBP
</p>
<p class="parrafo"><h3>
    ret
</p>
<p class="parrafo"><h3>
    Como las variables locales están en la pila, se utiliza también el registro
    apuntador RBP para acceder a las variables. Se utiliza un direccionamiento
    indexado sobre el registro RBP para acceder al espacio reservado, restando
    un valor al registro RSP.
</p>
<p class="parrafo"><h3>
    Ejemplo
</p>
<p class="parrafo"><h3>
    push rbp ;Almacenar el registro que utilizaremos
</p>
<p class="parrafo"><h3>
    ;de apuntador a la pila rbp
</p>
<p class="parrafo"><h3>
    mov rbp, rsp ;Asignar a RBP el valor del registro apuntador RSP
</p>
<p class="parrafo"><h3>
    sub rsp, 8 ;reservamos 8 bytes para variables locales
</p>
<p class="parrafo"><h3>
    mov al, byte[RBP-1] ;accedemos a 1 byte de almacenamiento local
</p>
<p class="parrafo"><h3>
    mov ax, word[RBP-2] ;accedemos a 2 bytes de almacenamiento local
</p>
<p class="parrafo"><h3>
    mov eax, dword[RBP-4] ;accedemos a 4 bytes de almacenamiento local
</p>
<p class="parrafo"><h3>
    mov rax, qword[RBP-8] ;accedemos a 8 bytes de almacenamiento local
</p>
<!-- -->
<h2> 5.4.2.  LLamada y retorno de subrutina</h2>
     <p class="parrafo"><h3>
    
        5.4.2. LLamada y retorno de subrutina</p>
    <p class="parrafo"><h3>
    5.4.2. Llamada y retorno de subrutina
</p> 
<p class="parrafo"><h3>
    Para hacer la llamada a la subrutina se utiliza la instrucción call y se
    indica la etiqueta que define el punto de entrada a la subrutina:
</p>
<p class="parrafo"><h3>
   call factorial
</p></h3>
<p class="parrafo"><h3>
    La instrucción call almacena en la pila la dirección de retorno (la
    dirección de la instrucción que se encuentra a continuación de la
    instrucción call) y entonces transfiere el control del programa a la
    subrutina, cargando en el registro RIP la dirección de la primera
    instrucción de la subrutina. Funcionalmente, la instrucción call anterior
    sería equivalente a:
</p>
<p class="parrafo"><h3>
    sub rsp, 8
</p>
<p class="parrafo"><h3>
    mov qword[rsp], rip
</p>
<p class="parrafo"><h3>
    mov rip, factorial
</p>
<p class="parrafo"><h3>
    Para finalizar la ejecución de la subrutina, ejecutaremos la instrucción
    ret, que recupera de la pila la dirección del registro RIP que hemos
    almacenado al hacer call y la carga otra vez en el registro RIP; continúa
    la ejecución del programa con la instrucción que se encuentra después de
    call. Funcionalmente, la instrucción ret sería equivalente a:
</p>
<p class="parrafo"><h3>
    mov rip, qword[rsp]
</p>
<p class="parrafo"><h3>
    add rsp, 8
</p>


<!-- -->
<h2> 5.4.3. Paso de parámetros a la subrutina y retorno de    resultados </h2>
     <p class="parrafo"><h3>
    
        5.4.3. Paso de parámetros a la subrutina y retorno de resultados
    
</p>
<p class="parrafo"><h3>
    Una subrutina puede necesitar que se le transfieran parámetros; los
    parámetros se pueden pasar mediante registros o la pila. Sucede lo mismo
    con el re[1]torno de resultados, que puede efectuarse por medio de registro
    o de la pila. Consideraremos los casos en los que el número de parámetros
    de entrada y de retorno de una subrutina es fijo. Paso de parámetros y
    retorno de resultado por medio de registros Debemos definir sobre qué
    registros concretos queremos pasar parámetros a la subrutina y sobre qué
    registros haremos el retorno; podemos utilizar cualquier registro de
    propósito general del procesador. Una vez definidos los registros que
    utilizaremos para hacer el paso de parámetros, deberemos asignar a cada uno
    el valor que queremos pasar a la subrutina antes de hacer call; para
    devolver los valores, dentro de la subrutina, tendremos que asignar a los
    registros correspondientes el valor que se debe devolver antes de hacer
    ret. Recordemos que los registros que se utilicen para devolver un valor no
    se han de almacenar en la pila al inicio de la subrutina, ya que no hay que
    conservar el valor inicial. Supongamos que en el ejemplo del factorial
    queremos pasar como parámetro un número cuyo factorial queremos calcular, y
    devolver como resultado el factorial del número transferido como parámetro,
    implementando el paso de parámetros y el retorno de resultados por medio de
    registros. El número cuya factorial queremos calcular lo pasaremos por
    medio del registro RBX y devolveremos el resultado al registro RAX. La
    llamada de la subrutina será:
</p>
<p class="parrafo"><h3>
    mov rbx, 5
</p>
<p class="parrafo"><h3>
    call factorial
</p>
<p class="parrafo"><h3>
    ;En rax tendremos el valor del factorial de 5 (=120)
</p>
<p class="parrafo"><h3>
    Subrutina:
</p>
<p class="parrafo"><h3>
    factorial:
</p>
<p class="parrafo"><h3>
    push rbx ; Almacenar en la pila el registro que modificamos
</p>
<p class="parrafo"><h3>
    ; y que no se utiliza para devolver el resultado.
</p>
<p class="parrafo"><h3>
    ; Instrucciones de la subrutina
</p>
<p class="parrafo"><h3>
    mov rax, 1 ; rax será el resultado
</p>
<p class="parrafo"><h3>
    while:
</p>
<p class="parrafo"><h3>
    imul rax, rbx
</p>
<p class="parrafo"><h3>
    dec rbx cmp rbx, 1 ; Se hace la comparación
</p>
<p class="parrafo"><h3>
    jg while ; Si se cumple la condición salta a while
</p>
<p class="parrafo"><h3>
    ; En rax tendremos el valor del factorial de rbx
</p>
<p class="parrafo"><h3>
    pop rbx ; Restauramos el valor inicial del registro
</p>
<p class="parrafo"><h3>
    ret
</p>
<p class="parrafo"><h3>
    Paso de parámetros y retorno de resultado por medio de la pila Si queremos
    pasar parámetros y devolver resultados a una subrutina utilizando la pila,
    y una vez definidos los parámetros que queremos pasar y los que queremos
    retornar, hay que hacer lo siguiente: 1) Antes de hacer la llamada a la
    subrutina: es necesario reservar espacio en la pila para los datos que
    queremos devolver y a continuación introducir los parámetros necesarios en
    la pila. 2)Dentro de la subrutina: hay que acceder a los parámetros
    leyéndolos di[1]rectamente de memoria, utilizando un registro que apunté a
    la cima de la pila. El registro apuntador de pila, RSP, siempre apunta a la
    cima de la pila y, por lo tanto, podemos acceder al contenido de la pila
    haciendo un direccionamiento a memoria que utilice RSP, pero si utilizamos
    la pila dentro de la subrutina, no se recomienda utilizarlo. El registro
    que se suele utilizar como apuntador para acceder a la pila es el registro
    RBP. Antes de utilizarlo, lo tendremos que almacenar en la pila para poder
    recuperar el valor inicial al final de la subrutina, a continuación, se
    carga en RBP el valor de RSP. RBP no se debe cambiar dentro de la
    subrutina; al final de esta se copia el valor sobre RSP para restaurar el
    valor inicial. 3) Después de ejecutar a subrutina: una vez fuera de la
    subrutina es necesario liberar el espacio utilizado por los parámetros de
    entrada y después recuperar los resultados del espacio que hemos reservado
    antes de hacer la llamada. CC-BY-SA • PID_00178132 75 Programación en
    ensamblador (x86-64) Supongamos que en el ejemplo de la factorial queremos
    pasar como parámetro el número cuyo factorial queremos calcular y devolver
    como resultado el factorial del número pasado como parámetro, implementando
    el paso de parámetros y el retorno de resultados por medio de la pila.
</p>
<p class="parrafo"><h3>
    La llamada de la subrutina:
</p>
<p class="parrafo"><h3>
    sub rsp,8 ; Reservamos 8 bytes para el resultado que devolvemos
</p>
<p class="parrafo"><h3>
    mov rbx, 5
</p>
<p class="parrafo"><h3>
    push rbx; Introducimos el parámetro de entrada en la pila
</p>
<p class="parrafo"><h3>
    call factorial
</p>
<p class="parrafo"><h3>
    add rsp,8 ; Liberamos el espacio utilizado por el parámetro de entrada
</p>
<p class="parrafo"><h3>
    pop rax ; Recuperamos el resultado devuelto sobre el registro rax
</p>
<p class="parrafo"><h3>
    Variables locales En los lenguajes de alto nivel es habitual definir
    variables locales dentro de las funciones definidas en un programa. Las
    variables locales ocupan un espacio definido dentro de la pila. Ahora
    veremos cómo reservar espacio para variables locales en subrutinas
    definidas en ensamblador. Para reservar el espacio necesario, hemos de
    saber cuántos bytes utilizaremos como variables locales. A continuación, es
    necesario decrementar el valor del apuntador a pila RSP tantas unidades
    como bytes se quieran reservar para las variables locales; de esta manera,
    si utilizamos las instrucciones que trabajan con la pila dentro de la
    subrutina (push y pop) no sobrescribiremos el espacio de las variables
    locales. La actualización de RSP se hace justo después de actualizar el
    registro que utilizamos para acceder a la pila, RBP.
</p>
<p class="parrafo"><h3>
    subrutina:
</p>
<p class="parrafo"><h3>
    push rbp ; Almacenar el registro que utilizaremos
</p>
<p class="parrafo"><h3>
    ; de apuntador a la pila rbp
</p>
<p class="parrafo"><h3>
    mov rbp, rsp ; Asignar a RBP el valor del registro apuntador RSP
</p>
<p class="parrafo"><h3>
    sub rsp, n ; n indica el número de bytes reservados para las
</p>
<p class="parrafo"><h3>
    ; variables locales
</p>
<p class="parrafo"><h3>
    ;
</p>
<p class="parrafo"><h3>
    ; Instrucciones de la subrutina
</p>
<p class="parrafo"><h3>
    ;
</p>
<p class="parrafo"><h3>
    mov rsp, rbp ; Restauramos el valor inicial de RSP con
</p>
<p class="parrafo"><h3>
    RBP
</p>
<p class="parrafo"><h3>
    pop rbp ; Restauramos el valor inicial de RBP
</p>
<p class="parrafo"><h3>
    ret
</p>
<p class="parrafo"><h3>
    Como las variables locales están en la pila, se utiliza también el registro
    apuntador RBP para acceder a las variables. Se utiliza un direccionamiento
    indexado sobre el registro RBP para acceder al espacio reservado, restando
    un valor al registro RSP.
</p>
<p class="parrafo"><h3>
    Ejemplo
</p>
<p class="parrafo"><h3>
    push rbp ;Almacenar el registro que utilizaremos
</p>
<p class="parrafo"><h3>
    ;de apuntador a la pila rbp
</p>
<p class="parrafo"><h3>
    mov rbp, rsp ;Asignar a RBP el valor del registro apuntador RSP
</p>
<p class="parrafo"><h3>
    sub rsp, 8 ;reservamos 8 bytes para variables locales
</p>
<p class="parrafo"><h3>
    mov al, byte[RBP-1] ;accedemos a 1 byte de almacenamiento local
</p>
<p class="parrafo"><h3>
    mov ax, word[RBP-2] ;accedemos a 2 bytes de almacenamiento local
</p>
<p class="parrafo"><h3>
    mov eax, dword[RBP-4] ;accedemos a 4 bytes de almacenamiento local
</p>
<p class="parrafo"><h3>
    mov rax, qword[RBP-8] ;accedemos a 8 bytes de almacenamiento local
</p>



<!-- -->
<p></p>
<br>
<br>
<a name="System calls"></a>
<br>
<br>
<h2>5.7. Funciones del sistema operativo (system calls)
</h2>
<p class="parrafo"><h3>El lenguaje de ensamblador proporciona dos mecanismos para poder hacer
llamadas al sistema operativo:</h3></p>
<p></P>
<h2>1)int 80h:</h2>
<p class="parrafo"><h3>este es el mecanismo tradicional</h3>
<p class="parrafo"><h3>El servicio que se solicita se especifica mediante el registro RAX. Los parámetros
necesarios para la ejecución del servicio vienen especificados por medio de los
registros RBX, RCX, RDX, RSI, RDI y RBP.</h3></p>
<p></P>
<h2>2)syscall:</h2>
<p class="parrafo"><h3>Es un mecanismo más eficiente de hacer r llamadas al sistema </h3></p>
<p></P>
<h2>5.7.1. Lectura de una cadena de caracteres desde el teclado
</h2>
<p class="parrafo"><h3>Lee caracteres del teclado hasta que se pulsa la tecla ENTER. La lectura de caracteres se hace llamando a la función de lectura read. Para utilizar esta función hay que especificar el descriptor de archivo que se utilizará; en el caso
de una lectura de teclado se utiliza el descriptor correspondiente a la entrada
estándar, un 0 en este caso.</h3></p>
<p></P>
<p class="parrafo"><h3>Según si se utiliza int 80h o syscall, los parámetros son los siguientes:</h3></p>
<p></P>
<h2>1)int 80h
</h2>
<p class="parrafo"><h3>a) Parámetros de entrada></h3></p>
<p></P>
<p class="parrafo"><h3>• RAX = 3
</h3></p>
<p class="parrafo"><h3>• RBX = 0, descriptor correspondiente a la entrada estándar (teclado)</h3></p>
<p class="parrafo"><h3>• RCX = dirección de la variable de memoria donde se guardará la cadena
leída</h3></p>
<p class="parrafo"><h3>• RDX = número máximo de caracteres que se leerán
</h3></p>
<p></P>
<p class="parrafo"><h3>b) Parámetros de salida	</h3></p>
<p></P>
<p class="parrafo"><h3>• RAX = número de caracteres leídos
</h3></p>
<p class="parrafo"><h3>• La variable indicada se llena con los caracteres leídos.
</h3></p>
<p></P>
<h2>2)syscall

</h2>
<p class="parrafo"><h3>a) Parámetros de entrada</h3></p>
<p></P>
<p class="parrafo"><h3>• RAX = 0</h3></p>
<p class="parrafo"><h3>• RDI = 0, descriptor correspondiente a la entrada estándar (teclado)
</h3></p>
<p class="parrafo"><h3>• RSI = dirección de la variable de memoria donde se guardará la cadena leída</h3></p>
<p class="parrafo"><h3>• RDX = número máximo de caracteres que se leerán</h3></p>
<p></P>
<p class="parrafo"><h3>b) Parámetros de salida</h3></p>
<p></P>
<p class="parrafo"><h3>• RAX = número de caracteres leídos
</h3></p>
<div class="img1" >
<img src="lectura.png" class="rounded mx-auto d-block"  >
</div>
<h2>5.7.2. Escritura de una cadena de caracteres por pantalla
</h2>
<p class="parrafo"><h3>La escritura de caracteres por pantalla se efectúa llamando a la función de
escritura write. Para utilizar esta función hay que especificar el descriptor de
archivo que se utilizará; en el caso de una escritura por pantalla se utiliza el
descriptor correspondiente a la salida estándar, un 1 en este caso.
</h3></p>
<p></P>
<h2>1)int 80h
</h2>
<p class="parrafo"><h3>a) Parámetros de entrada</h3></p>
<p></P>
<p class="parrafo"><h3>• RAX = 4</h3></p>
<p class="parrafo"><h3>• RBX = 1, descriptor correspondiente a la salida estándar (pantalla)</h3></p>
<p class="parrafo"><h3>• RCX = dirección de la variable de memoria que queremos escribir, la variable ha de estar definida con un byte 0 al final
</h3></p>
<p class="parrafo"><h3>• RDX = tamaño de la cadena que queremos escribir en bytes, incluido el
0 del final</h3></p>
<p class="parrafo"><h3>b) Parámetros de salida</h3></p>
<p class="parrafo"><h3>• RAX = número de caracteres escritos
</h3></p>
<p></P>
<h2>2)syscall
</h2>
<p class="parrafo"><h3>a) Parámetros de entrada</h3></p>
<p></P>
<p class="parrafo"><h3>• RAX = 1</h3></p>
<p class="parrafo"><h3>• RDI = 1, descriptor correspondiente a la salida estándar (pantalla)
</h3></p>
<p class="parrafo"><h3>• RSI = dirección de la variable de memoria que queremos escribir, la variable
ha de estar definida con un byte 0 al final</h3></p>
<p class="parrafo"><h3>• RDX = tamaño de la cadena que queremos escribir en bytes, incluido el
0 del final</h3></p>
<p></P>

<p class="parrafo"><h3>b) Parámetros de salida</h3></p>
<p></P>

<p class="parrafo"><h3>• RAX = número de caracteres escritos</h3></p>
<p></P>
<div class="img1" >
<img src="escritura.png" class="rounded mx-auto d-block"  >
</div>
<p></p>

<!-- -->
<br>
<br>
<a name="Operadores"></a>
<br>
<br>
<h2>6.1. ADC: suma aritmética con bit de transporte
</h2>
<p class="parrafo"><h3>ADC destino, fuente</h3></p>
<p></P>
<p class="parrafo"><h3>Efectúa una suma aritmética; suma el operando fuente y el valor del bit de
transporte (CF) al operando de destino, almacena el resultado sobre el operando destino y sustituye el valor inicial del operando destino.
</h3></p>
<p></P>

<p class="parrafo"><h3>Operación</h3></p>
<p></P>
<p class="parrafo"><h3>destino = destino + fuente + CF</h3></p>
<p></P>

<p class="parrafo"><h3>Bits de resultado modificados</h3></p>
<p></P>
<p class="parrafo"><h3>OF, SF, ZF, AF, PF, CF</h3></p>
<p></P>
<p class="parrafo"><h3>Si el resultado no cabe dentro del operando destino, el bit de transporte se
pone a 1. El resto de bits de resultado se modifican según el resultado de la
operación.</h3></p>
<p></P>
<p class="parrafo"><h3>Formatos válidos</h3></p>
<p></P>
<p class="parrafo"><h3>ADC reg, reg</h3></p>
<p></P>
<p class="parrafo"><h3>ADC reg, tamaño mem
</h3></p>
<p></P>
<p class="parrafo"><h3>ADC tamaño mem, reg</h3></p>
<p></P>
<p class="parrafo"><h3>Los dos operandos han de ser del mismo tamaño.</h3></p>
<p></P>
<p class="parrafo"><h3>ADC reg, imm</h3></p>
<p></P>
<p class="parrafo"><h3>ADC tamaño mem, imm</h3></p>
<p></P>
<p class="parrafo"><h3>El tamaño del inmediato puede ir desde 8 bits hasta el tamaño del primer
operando, 32 bits como máximo.</h3></p>
<p></P>
<div class="img1" >
<img src="ADC.png" class="rounded mx-auto d-block"  >
</div>
<p></p>
<!-- -->

<h2>6.2. ADD: suma aritmética<h2>
<p class="parrafo"><h3>Efectúa la suma aritmética de los dos operandos de la instrucción, almacena
el resultado sobre el operando destino y sustituye el valor inicial del operando
destino</h3></p>
<p class="parrafo"><h3>Si el resultado no cabe dentro del operando destino, el bit de transporte se
pone a 1. El resto de bits de resultado se modifican según el resultado de la
operación.</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>ADD R9,RAX</h5></p>

<h2>6.3. AND: Y lógica</h2>
<p class="parrafo"><h3>Realiza una operación lógica AND ('y lógica') bit a bit entre el operando destino
y el operando fuente, el resultado de la operación se guarda sobre el operando
destino sobreescribiendo el valor inicial. El valor del operando fuente no se
modifica.</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>AND R9,RAX</h5></p>

<h2>6.4. CALL: llamada a subrutina</h2>
<p class="parrafo"><h3>Llama a la subrutina que se encuentra en la dirección de memoria indicada por
la etiqueta. Guarda en la pila la dirección de memoria de la instrucción que
sigue en secuencia la instrucción CALL y permite el retorno desde la subrutina
con la instrucción RET; a continuación carga en el RIP (instruction pointer) la
dirección de memoria donde está la etiqueta especificada en la instrucción y
transfiere el control a la subrutina</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>CALL subrutina1</h5></p>

<!-- -->

<!-- CMP-->

<h2>6.5. CMP: comparación aritmética
</h2>
<p class="parrafo"><h3>CMP destino, fuente</h3></p>
<p></P>
<p class="parrafo"><h3>Compara los dos operandos de la instrucción sin afectar al valor de ninguno
de los operandos, actualiza los bits de resultado según el resultado de la comparación. La comparación se realiza con una resta entre los dos operandos, sin
considerar el transporte y sin guardar el resultado.</h3></p>
<p></P>
<p class="parrafo"><h3>Bits de resultado modificados</h3></p>
<p></P>
<p class="parrafo"><h3>OF, SF, ZF, AF, PF, CF</h3></p>
<p></P>
<p class="parrafo"><h3>Los bits de resultado se modifican según el resultado de la operación de resta.</h3></p>
<p></P>
<p class="parrafo"><h3>Formatos válidos</h3></p>
<p></P>
<p class="parrafo"><h3>CMP reg,reg</h3></p>
<p class="parrafo"><h3>CMP reg,tamaño mem</h3></p>
<p class="parrafo"><h3>CMP tamaño mem,reg</h3></p>
<p></P>
<p class="parrafo"><h3>Los dos operandos han de ser del mismo tamaño.</h3></p>
<p></P>
<p class="parrafo"><h3>CMP reg,imm</h3></p>
<p class="parrafo"><h3>CMP tamaño mem,imm</h3></p>
<p></P>
<p class="parrafo"><h3>El tamaño del inmediato puede ir desde 8 bits hasta el tamaño del primer
operando, como máximo 32 bits.
</h3></p>
<p></P>
<div class="img1" >
<img src="CMP.png" class="rounded mx-auto d-block"  >
</div>
<p></p>
<h2>6.6. DEC: decrementa el operando
</h2>
<p class="parrafo"><h3>DEC destino</h3></p>
<p></P>
<p class="parrafo"><h3>Resta 1 al operando de la instrucción y almacena el resultado en el mismo
operando</h3></p>
<p></P>
<p class="parrafo"><h3>Operación</h3></p>
<p></P>
<p class="parrafo"><h3>destino = destino – 1</h3></p>
<p></P>
<p class="parrafo"><h3>Bits de resultado modificados</h3></p>
<p></P>
<p class="parrafo"><h3>OF, SF, ZF, AF, PF</h3></p>
<p></P>
<h2>
</h2>
<p class="parrafo"><h3>Los bits de resultado se modifican según el resultado de la operación</h3></p>
<p></P>
<h2>
</h2>
<p class="parrafo"><h3>Formatos válidos</h3></p>
<p></P>
<h2>
</h2>
<p class="parrafo"><h3>DEC reg</h3></p>
<p class="parrafo"><h3>DEC tamaño mem</h3></p>
<p></P>
<div class="img1" >
<img src="DEC.png" class="rounded mx-auto d-block"  >
</div>
<p></p>
<h2>6.7. DIV: división entera sin signo
</h2>
<p class="parrafo"><h3>DIV fuente</h3></p>
<p></P>
<p class="parrafo"><h3>Divide el dividendo implícito entre el divisor explícito sin considerar los signos
de los operandos.
</h3></p>
<p></P>
<p class="parrafo"><h3>Si el divisor es de 8 bits, se considera como dividendo implícito AX. El cociente
de la división queda en AL y el resto, en AH.</h3></p>
<p></P>
<p class="parrafo"><h3>Operación</h3></p>
<p></P>
<p class="parrafo"><h3>Si fuente es de 8 bits: AL = AX / fuente, AH = AX mod fuente</h3></p>
<p class="parrafo"><h3>Si fuente es de 16 bits: AX = DX:AX / fuente, DX = DX:AX mod fuente
</h3></p>
<p class="parrafo"><h3>Si fuente es de 32 bits: EAX = EDX:EAX / fuente, EDX = EDX:EAX mod
fuente</h3></p>
<p class="parrafo"><h3>Si fuente es de 64 bits: RAX = RDX:RAX / fuente, RDX = RDX:RAX mod
fuente</h3></p>
<p></P>
<p class="parrafo"><h3>Bits de resultado modificados
</h3></p>
<p></P>
<p class="parrafo"><h3>OF, SF, ZF, AF, PF, CF</h3></p>
<p></P>
<p class="parrafo"><h3>La instrucción DIV no deja información a los bits de resultado, pero estos
quedan indefinidos.</h3></p>
<p></P>
<p class="parrafo"><h3>Formatos válidos</h3></p>
<p></P>
<p class="parrafo"><h3>DIV reg
</h3></p>
<p class="parrafo"><h3>DIV tamaño mem</h3></p>
<p></P>
<div class="img1" >
<img src="DIV.png" class="rounded mx-auto d-block"  >
</div>
<p></p>
<h2>
</h2>
<p class="parrafo"><h3></h3></p>
<p></P>
<h2>
</h2>
<p class="parrafo"><h3></h3></p>
<p></P>
<!-- -->


<!-- -->

<h2>6.9.2. IMUL destino, fuente: dos operandos explícitos</h2>
<p class="parrafo"><h3>Multiplica el operando fuente por el operando destino considerando el signo
de los dos operandos y almacena el resultado en el operando destino; sobreescribe el valor que tuviera</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>IMUL EAX, 4</h5></p>


<h2>6.10. IN: lectura de un puerto de entrada/salida</h2>
<p class="parrafo"><h3>Lee el valor de un puerto de E/S especificado por el operando fuente y lleva
el valor al operando destino.
<br>
El operando fuente puede ser un valor inmediato de 8 bits, que permite acceder
a los puertos 0-255, o el registro DX, que permite acceder a cualquier puerto
de E/S de 0-65535.</h3></p>
<p class="parrafo"><h3>El operando destino solo puede ser uno de los registros siguientes:
<br>
• AL se lee un byte del puerto
<br>
• AX se leen dos bytes
<br>
• EAX se leen cuatro bytes
</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>IN AL, 60 h</h5></p>


<h2>6.11. INC: incrementa el operando</h2>
<p class="parrafo"><h3>Suma 1 al operando de la instrucción y almacena el resultado en el mismo
operando.</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>INC R9</h5></p>

<h2>6.24. PUSH: introducir un valor en la pila</h2>
<p class="parrafo"><h3>Se actualiza el valor del registro apuntador de pila, RSP, decrementándolo en
tantas unidades como el tamaño en bytes del operando fuente.
<br>
A continuación, se introduce el valor del operando fuente en la cima de la pila,
se copia el valor del operando a la posición de la memoria apuntada por el
registro RSP y se colocan tantos bytes en la pila como el tamaño del operando
indicado.
<br>
El operando puede ser un registro de 16 o 64 bits, una posición de memoria
de 16 o 64 bits o un valor inmediato de 8, 16 o 32 bits extendido a 64 bits.</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>PUSH RAX</h5></p>

<h2>6.25. RET: retorno de subrutina</h2>
<p class="parrafo"><h3>Sale de la subrutina que se estaba ejecutando y retorna al punto donde se había
hecho la llamada, a la instrucción siguiente de la instrucción CALL.
<br>
Extrae de la pila la dirección de memoria de retorno (la dirección de la instrucción que sigue en secuencia a la instrucción CALL) y la carga en el RIP
(instruction pointer).
<br>
Actualiza el puntero de pila (registro RSP), para que apunte al siguiente elemento de la pila; como la dirección de retorno es de 8 bytes (en modo de 64
bits), incrementa RSP en 8 unidades.
</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>RET</h5></p>


<h2>6.26. ROL: rotación a la izquierda</h2>
<p class="parrafo"><h3>Lleva a cabo una rotación de los bits del operando destino a la izquierda, es
decir, hacia al bit más significativo; rota tantos bits como indica el operando
fuente.
<br>
Los bits pasan de la posición que ocupan a la posición de su izquierda; el
bit de la posición más significativa pasa a la posición menos significativa del
operando.
<br>
El operando fuente solo puede ser un valor inmediato de 8 bits o el registro CL.
<br>
Si el operando destino es de 64 bits, se enmascarán los dos bits de más peso
del operando fuente, lo que permite rotaciones de 0 a 63 bits.
<br>
Si el operando destino es de 32 bits o menos, se enmascarán los tres bits de
más peso del operando fuente, lo que permite rotaciones de 0 a 31 bits</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>ROL RAX,CL</h5></p>

<h2>6.27. ROR: rotación a la derecha</h2>
<p class="parrafo"><h3>Realiza una rotación de los bits del operando destino a la derecha, es decir, hacia al bit menos significativo; rota tantos bits como indica el operando fuente.
<br>
Los bits pasan desde la posición que ocupan a la posición de su derecha; el
bit de la posición menos significativa pasa a la posición más significativa del
operando.
<br>
El operando fuente solo puede ser un valor inmediato de 8 bits o el registro CL.
Si el operando destino es de 64 bits, se enmascaran los dos bits de más peso
del operando fuente, lo que permite rotaciones de 0 a 63 bits.
<br>
Si el operando destino es de 32 bits o menos, se enmascaran los tres bits de
más peso del operando fuente, lo que permite rotaciones de 0 a 31 bits.
</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>ROR RAX,1</h5></p>


<h2>6.28. SAL: desplazamiento aritmético (o lógico) a la izquierda</h2>
<p class="parrafo"><h3>Lleva a cabo un desplazamiento a la izquierda de los bits del operando destino;
desplaza tantos bits como indica el operando fuente.
<br>
Los bits pasan de la posición que ocupan a la posición de su izquierda y se
van añadiendo ceros por la derecha; el bit más significativo se traslada al bit
de transporte (CF).
<br>
El operando fuente solo puede ser un valor inmediato de 8 bits o el registro CL.
Si el operando destino es de 64 bits, se enmascaran los dos bits de más peso
del operando fuente, lo que permite desplazamientos de 0 a 63 bits.
<br>
Si el operando destino es de 32 bits o menos, se enmascaran los tres bits de
más peso del operando fuente, lo que permite desplazamientos de 0 a 31 bits.
La operación es equivalente a multiplicar por 2 el valor del operando destino
tantas veces como indica el operando fuente.</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>SAL RAX,1</h5></p>

<h2>6.29. SAR: desplazamiento aritmético a la derecha</h2>
<p class="parrafo"><h3>Lleva a cabo un desplazamiento a la derecha de los bits del operando destino;
desplaza tantos bits como indica el operando fuente.
<br>
Los bits pasan de la posición que ocupan a la posición de su derecha; el bit de
signo (el bit más significativo) se va copiando a las posiciones de la derecha;
el bit menos significativo se copia al bit de transporte (CF).
<br>
El operando fuente solo puede ser un valor inmediato de 8 bits o el registro CL.
Si el operando destino es de 64 bits, se enmascaran los dos bits de más peso
del operando fuente, lo que permite desplazamientos de 0 a 63 bits.
<br>
Si el operando destino es de 32 bits o menos, se enmascaran los tres bits de
más peso del operando fuente, lo que permite desplazamientos de 0 a 31 bits.
La operación es equivalente a dividir por 2 el valor del operando destino tantas
veces como indica el operando fuente.
</h3></p>
<p class="parrafo"><h3>EJEMPLO:</h3></p>
<p class="parrafo"><h5>SAR RAX,1
</h5></p>
<!-- -->
</div>
</div>
</div>
   </div>
   </div>
   </div>

    <!-- Optional JavaScript; choose one of the two! -->

    <!-- Option 1: Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>

    <!-- Option 2: Separate Popper and Bootstrap JS -->
    <!--
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
    -->
  </body>
</html>